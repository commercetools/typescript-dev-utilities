import forEach from 'lodash.foreach';
import sortBy from 'lodash.sortby';

import isEqual from 'lodash.isequal';
import createBuildArrayActions, {
  ADD_ACTIONS,
  CHANGE_ACTIONS,
} from '../utils-ts/create-build-array-actions';
import { buildBaseAttributesActions } from '../utils-ts/common-actions';
import * as diffPatcher from '../utils-ts/diffpatcher';
import extractMatchingPairs from '../utils-ts/extract-matching-pairs';
import {
  CustomFieldEnumType,
  CustomFieldEnumValue,
  Delta,
  FieldDefinition,
  SyncActionConfig,
  UpdateAction,
} from '../utils-ts/types';

const REGEX_NUMBER = new RegExp(/^\d+$/);
const REGEX_UNDERSCORE_NUMBER = new RegExp(/^_\d+$/);
const getIsChangedOperation = (key: string) => REGEX_NUMBER.test(key);
const getIsRemovedOperation = (key: string) =>
  REGEX_UNDERSCORE_NUMBER.test(key);

export const baseActionsList: Array<UpdateAction> = [
  { action: 'changeKey', key: 'key' },
  { action: 'changeName', key: 'name' },
  { action: 'setDescription', key: 'description' },
];

export function actionsMapBase<T = CustomFieldEnumType | FieldDefinition>(
  diff: Delta,
  oldObj: T,
  newObj: T,
  config: SyncActionConfig = {}
) {
  return buildBaseAttributesActions({
    actions: baseActionsList,
    diff,
    oldObj,
    newObj,
    shouldOmitEmptyString: config.shouldOmitEmptyString,
    shouldUnsetOmittedProperties: config.shouldUnsetOmittedProperties,
    shouldPreventUnsettingRequiredFields:
      config.shouldPreventUnsettingRequiredFields,
  });
}

function actionsMapEnums<S extends CustomFieldEnumType>(
  fieldName: string,
  attributeType: string,
  attributeDiff: Delta,
  previous: S,
  next: S
) {
  const addEnumActionName =
    attributeType === 'Enum' ? 'addEnumValue' : 'addLocalizedEnumValue';

  const changeEnumValueLabelActionName =
    attributeType === 'Enum'
      ? 'changeEnumValueLabel'
      : 'changeLocalizedEnumValueLabel';

  const changeEnumOrderActionName =
    attributeType === 'Enum'
      ? 'changeEnumValueOrder'
      : 'changeLocalizedEnumValueOrder';

  const buildArrayActions = createBuildArrayActions('values', {
    [ADD_ACTIONS]: (newEnum: CustomFieldEnumType) => ({
      fieldName,
      action: addEnumActionName,
      value: newEnum,
    }),
    [CHANGE_ACTIONS]: (
      oldEnum: CustomFieldEnumValue,
      newEnum: CustomFieldEnumValue
    ) => {
      const oldEnumInNext = next.values.find(
        (nextEnum) => nextEnum.key === oldEnum.key
      );

      // These `changeActions` would impose a nested structure among
      // the accumulated `updateActions` generated by `buildArrayActions`
      // In the end; we have to flatten the structure before we pass it back
      // to the client.
      const changeActions = [];
      if (oldEnumInNext) {
        // If the enum value is changed, we need to change the order first
        const isKeyChanged = oldEnum.key !== newEnum.key;

        // check if the label is changed
        const foundPreviousEnum = previous.values.find(
          (previousEnum) => previousEnum.key === newEnum.key
        );
        const isLabelEqual = isEqual(foundPreviousEnum.label, newEnum.label);

        if (isKeyChanged) {
          // these actions is then flatten in the end
          changeActions.push({
            fieldName,
            action: changeEnumOrderActionName,
            value: newEnum,
          });
        }

        if (!isLabelEqual) {
          changeActions.push({
            fieldName,
            action: changeEnumValueLabelActionName,
            value: newEnum,
          });
        }
      } else {
        changeActions.push({
          fieldName,
          action: addEnumActionName,
          value: newEnum,
        });
      }
      return changeActions;
    },
  });

  const actions = [];
  // following lists are necessary to ensure that when we change the
  // order of enumValues, we generate one updateAction instead of one at a time.
  let newEnumValuesOrder = [];

  buildArrayActions(attributeDiff, previous, next)
    .flat()
    .forEach((updateAction) => {
      if (updateAction.action === changeEnumOrderActionName) {
        newEnumValuesOrder = next.values.map((enumValue) => enumValue.key);
      } else actions.push(updateAction);
    });

  return [
    ...actions,
    ...(newEnumValuesOrder.length > 0
      ? [
          {
            fieldName,
            action: changeEnumOrderActionName,
            keys: newEnumValuesOrder,
          },
        ]
      : []),
  ];
}

export function actionsMapFieldDefinitions(
  fieldDefinitionsDiff: Delta,
  previous: FieldDefinition,
  next: FieldDefinition | Array<FieldDefinition>,
  diffPaths: Delta
) {
  const actions = [];
  forEach(
    fieldDefinitionsDiff,
    (diffValue: FieldDefinition, diffKey: string) => {
      const extractedPairs = extractMatchingPairs<FieldDefinition>(
        diffPaths,
        diffKey,
        previous,
        next as FieldDefinition
      );

      if (getIsChangedOperation(diffKey)) {
        if (Array.isArray(diffValue)) {
          const deltaValue =
            diffPatcher.getDeltaValue<FieldDefinition>(diffValue);
          if (deltaValue.name) {
            actions.push({
              action: 'addFieldDefinition',
              fieldDefinition: deltaValue,
            });
          }
        } else if (diffValue.label) {
          actions.push({
            action: 'changeLabel',
            label: extractedPairs.newObj.label,
            fieldName: extractedPairs.oldObj.name,
          });
        } else if (diffValue.inputHint) {
          actions.push({
            action: 'changeInputHint',
            inputHint: extractedPairs.newObj.inputHint,
            fieldName: extractedPairs.oldObj.name,
          });
        } else if (diffValue?.type?.['values']) {
          actions.push(
            ...actionsMapEnums(
              extractedPairs.oldObj.name,
              extractedPairs.oldObj.type.name,
              diffValue.type,
              extractedPairs.oldObj.type as unknown as CustomFieldEnumType,
              extractedPairs.newObj.type as unknown as CustomFieldEnumType
            )
          );
        }
      } else if (getIsRemovedOperation(diffKey)) {
        if (Array.isArray(diffValue)) {
          if (diffValue.length === 3 && diffValue[2] === 3) {
            actions.push({
              action: 'changeFieldDefinitionOrder',
              fieldNames: (next as Array<FieldDefinition>).map((n) => n.name),
            });
          } else {
            const deltaValue = diffPatcher.getDeltaValue(diffValue);
            if (deltaValue === undefined && diffValue[0].name)
              actions.push({
                action: 'removeFieldDefinition',
                fieldName: diffValue[0].name,
              });
          }
        }
      }
    }
  );

  // Make sure to execute removeActions before creating new ones
  // in order to prevent any eventual removal of `addAction`.
  // List of `removeActions` can be found here
  // https://docs.commercetools.com/api/projects/types#change-key
  const sortedActions = sortBy(
    actions,
    (action: UpdateAction) => action.action !== 'removeFieldDefinition'
  );

  return sortedActions;
}
